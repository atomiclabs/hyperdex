{"version":3,"file":"xml.js","sourceRoot":"","sources":["../src/xml.ts"],"names":[],"mappings":"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","sourcesContent":["import * as sax from \"sax\"\nimport { newError } from \"./index\"\n\nexport class XElement {\n  value = \"\"\n  attributes: { [key: string]: string } | null = null\n  isCData = false\n  elements: Array<XElement> | null = null\n\n  constructor(readonly name: string) {\n    if (!name) {\n      throw newError(\"Element name cannot be empty\", \"ERR_XML_ELEMENT_NAME_EMPTY\")\n    }\n    if (!isValidName(name)) {\n      throw newError(`Invalid element name: ${name}`, \"ERR_XML_ELEMENT_INVALID_NAME\")\n    }\n  }\n\n  attribute(name: string): string {\n    const result = this.attributes === null ? null : this.attributes[name]\n    if (result == null) {\n      throw newError(`No attribute \"${name}\"`, \"ERR_XML_MISSED_ATTRIBUTE\")\n    }\n    return result\n  }\n\n  removeAttribute(name: string): void {\n    if (this.attributes !== null) {\n      delete this.attributes[name]\n    }\n  }\n\n  element(name: string, ignoreCase = false, errorIfMissed: string | null = null): XElement {\n    const result = this.elementOrNull(name, ignoreCase)\n    if (result === null) {\n      throw newError(errorIfMissed || `No element \"${name}\"`, \"ERR_XML_MISSED_ELEMENT\")\n    }\n    return result\n  }\n\n  elementOrNull(name: string, ignoreCase = false): XElement | null {\n    if (this.elements === null) {\n      return null\n    }\n\n    for (const element of this.elements) {\n      if (isNameEquals(element, name, ignoreCase)) {\n        return element\n      }\n    }\n\n    return null\n  }\n\n  getElements(name: string, ignoreCase = false) {\n    if (this.elements === null) {\n      return []\n    }\n    return this.elements.filter(it => isNameEquals(it, name, ignoreCase))\n  }\n\n  elementValueOrEmpty(name: string, ignoreCase = false): string {\n    const element = this.elementOrNull(name, ignoreCase)\n    return element === null ? \"\" : element.value\n  }\n}\n\nconst NAME_REG_EXP = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i)\n\nfunction isValidName(name: string) {\n  return (NAME_REG_EXP.test(name))\n}\n\nfunction isNameEquals(element: XElement, name: string, ignoreCase: boolean) {\n  const elementName = element.name\n  return elementName === name || (ignoreCase === true && elementName.length === name.length && elementName.toLowerCase() === name.toLowerCase())\n}\n\nexport function parseXml(data: string): XElement {\n  let rootElement: XElement | null = null\n  const parser = sax.parser(true, {})\n  const elements: Array<XElement> = []\n\n  parser.onopentag = saxElement => {\n    const element = new XElement(saxElement.name)\n    element.attributes = saxElement.attributes as { [key: string]: string }\n\n    if (rootElement === null) {\n      rootElement = element\n    }\n    else {\n      const parent = elements[elements.length - 1]\n      if (parent.elements == null) {\n        parent.elements = []\n      }\n      parent.elements.push(element)\n    }\n    elements.push(element)\n  }\n\n  parser.onclosetag = () => {\n    elements.pop()\n  }\n\n  parser.ontext = text => {\n    if (elements.length > 0) {\n      elements[elements.length - 1].value = text\n    }\n  }\n\n  parser.oncdata = cdata => {\n    const element = elements[elements.length - 1]\n    element.value = cdata\n    element.isCData = true\n  }\n\n  parser.onerror = err => {\n    throw err\n  }\n\n  parser.write(data)\n  return rootElement!!\n}"]}
