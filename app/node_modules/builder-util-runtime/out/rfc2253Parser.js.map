{"version":3,"file":"rfc2253Parser.js","sourceRoot":"","sources":["../src/rfc2253Parser.ts"],"names":[],"mappings":";;;;;;;iBAAwB,AAAW;AACjC,MAAI,AAAM,SAAG,AAAK;AAClB,MAAI,AAAG,MAAkB,AAAI;AAC7B,MAAI,AAAK,QAAG,AAAE;AACd,MAAI,AAAY,eAAG,AAAC;AAEpB,AAAG,QAAG,AAAG,IAAC,AAAI,AAAE;AAChB,QAAM,AAAM,SAAG,IAAI,AAAG,AAAkB;;AACxC,OAAK,IAAI,AAAC,IAAG,AAAC,GAAE,AAAC,KAAI,AAAG,IAAC,AAAM,QAAE,AAAC,AAAE,KAAE;AACpC,QAAI,AAAC,MAAK,AAAG,IAAC,AAAM,QAAE;AACpB,UAAI,AAAG,QAAK,AAAI,MAAE;AAChB,AAAM,eAAC,AAAG,IAAC,AAAG,KAAE,AAAK,AAAC;AACvB;;AACD,AAAK;AACN;;AAED,UAAM,AAAE,KAAG,AAAG,IAAC,AAAC,AAAC;;AACjB,QAAI,AAAM,QAAE;AACV,UAAI,AAAE,OAAK,AAAG,KAAE;AACd,AAAM,iBAAG,AAAK;AACd,AAAQ;AACT;AACF,WACI;AACH,UAAI,AAAE,OAAK,AAAG,KAAE;AACd,AAAM,iBAAG,AAAI;AACb,AAAQ;AACT;;AAED,UAAI,AAAE,OAAK,AAAI,MAAE;AACf,AAAC,AAAE;AACH,cAAM,AAAG,MAAG,AAAQ,SAAC,AAAG,IAAC,AAAK,MAAC,AAAC,GAAE,AAAC,IAAG,AAAC,AAAC,IAAE,AAAE,AAAC;;AAC7C,YAAI,AAAM,OAAC,AAAK,MAAC,AAAG,AAAC,MAAE;AACrB,AAAK,mBAAI,AAAG,IAAC,AAAC,AAAC;AAChB,eACI;AACH,AAAC,AAAE;AACH,AAAK,mBAAI,AAAM,OAAC,AAAY,aAAC,AAAG,AAAC;AAClC;;AACD,AAAQ;AACT;;AAED,UAAI,AAAG,QAAK,AAAI,QAAI,AAAE,OAAK,AAAG,KAAE;AAC9B,AAAG,cAAG,AAAK;AACX,AAAK,gBAAG,AAAE;AACV,AAAQ;AACT;;AAED,UAAI,AAAE,OAAK,AAAG,OAAI,AAAE,OAAK,AAAG,OAAI,AAAE,OAAK,AAAG,KAAE;AAC1C,YAAI,AAAG,QAAK,AAAI,MAAE;AAChB,AAAM,iBAAC,AAAG,IAAC,AAAG,KAAE,AAAK,AAAC;AACvB;;AACD,AAAG,cAAG,AAAI;AACV,AAAK,gBAAG,AAAE;AACV,AAAQ;AACT;AACF;;AAED,QAAI,AAAE,OAAK,AAAG,OAAI,CAAC,AAAM,QAAE;AACzB,UAAI,AAAK,MAAC,AAAM,WAAK,AAAC,GAAE;AACtB,AAAQ;AACT;;AAED,UAAI,AAAC,IAAG,AAAY,cAAE;AACpB,YAAI,AAAC,IAAG,AAAC;;AACT,eAAO,AAAG,IAAC,AAAC,AAAC,OAAK,AAAG,KAAE;AACrB,AAAC,AAAE;AACJ;;AACD,AAAY,uBAAG,AAAC;AACjB;;AAED,UAAI,AAAY,gBAAI,AAAG,IAAC,AAAM,UACzB,AAAG,IAAC,AAAY,AAAC,kBAAK,AAAG,OACzB,AAAG,IAAC,AAAY,AAAC,kBAAK,AAAG,AACzB,OAAC,AAAG,QAAK,AAAI,QAAI,AAAG,IAAC,AAAY,AAAC,kBAAK,AAAG,AAAC,AAC3C,OAAC,AAAG,QAAK,AAAI,QAAI,AAAG,IAAC,AAAY,AAAC,kBAAK,AAAG,AAAC,KAC9C;AACA,AAAC,YAAG,AAAY,eAAG,AAAC;AACpB,AAAQ;AACT;AACF;;AAED,AAAK,aAAI,AAAE;AACZ;;AAED,SAAO,AAAM,AACf;AAAC","sourcesContent":["export function parseDn(seq: string): Map<string, string> {\n  let quoted = false\n  let key: string | null = null\n  let token = \"\"\n  let nextNonSpace = 0\n\n  seq = seq.trim()\n  const result = new Map<string, string>()\n  for (let i = 0; i <= seq.length; i++) {\n    if (i === seq.length) {\n      if (key !== null) {\n        result.set(key, token)\n      }\n      break\n    }\n\n    const ch = seq[i]\n    if (quoted) {\n      if (ch === '\"') {\n        quoted = false\n        continue\n      }\n    }\n    else {\n      if (ch === '\"') {\n        quoted = true\n        continue\n      }\n\n      if (ch === \"\\\\\") {\n        i++\n        const ord = parseInt(seq.slice(i, i + 2), 16)\n        if (Number.isNaN(ord)) {\n          token += seq[i]\n        }\n        else {\n          i++\n          token += String.fromCharCode(ord)\n        }\n        continue\n      }\n\n      if (key === null && ch === \"=\") {\n        key = token\n        token = \"\"\n        continue\n      }\n\n      if (ch === \",\" || ch === \";\" || ch === \"+\") {\n        if (key !== null) {\n          result.set(key, token)\n        }\n        key = null\n        token = \"\"\n        continue\n      }\n    }\n\n    if (ch === \" \" && !quoted) {\n      if (token.length === 0) {\n        continue\n      }\n\n      if (i > nextNonSpace) {\n        let j = i\n        while (seq[j] === \" \") {\n          j++\n        }\n        nextNonSpace = j\n      }\n\n      if (nextNonSpace >= seq.length\n        || seq[nextNonSpace] === \",\"\n        || seq[nextNonSpace] === \";\"\n        || (key === null && seq[nextNonSpace] === \"=\")\n        || (key !== null && seq[nextNonSpace] === \"+\")\n      ) {\n        i = nextNonSpace - 1\n        continue\n      }\n    }\n\n    token += ch\n  }\n\n  return result\n}"]}
