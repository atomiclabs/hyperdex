{"version":3,"file":"DownloadedUpdateHelper.js","sourceRoot":"","sources":["../src/DownloadedUpdateHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import { UpdateInfo } from \"builder-util-runtime\"\nimport { createHash } from \"crypto\"\nimport { createReadStream } from \"fs\"\nimport isEqual from \"lodash.isequal\"\nimport { Logger, ResolvedUpdateFileInfo } from \"./main\"\nimport { pathExists } from \"fs-extra-p\"\n\n/** @private **/\nexport class DownloadedUpdateHelper {\n  private _file: string | null = null\n  private _packageFile: string | null = null\n\n  private versionInfo: UpdateInfo | null = null\n  private fileInfo: ResolvedUpdateFileInfo | null = null\n\n  constructor(readonly cacheDir: string) {\n  }\n\n  get file() {\n    return this._file\n  }\n\n  get packageFile() {\n    return this._packageFile\n  }\n\n  async validateDownloadedPath(updateFile: string, versionInfo: UpdateInfo, fileInfo: ResolvedUpdateFileInfo, logger: Logger): Promise<boolean> {\n    if (this.versionInfo != null && this.file === updateFile) {\n      // update has already been downloaded from this running instance\n      // check here only existence, not checksum\n      return isEqual(this.versionInfo, versionInfo) && isEqual(this.fileInfo, fileInfo) && (await pathExists(updateFile))\n    }\n\n    // update has already been downloaded from some previous app launch\n    if (await DownloadedUpdateHelper.isUpdateValid(updateFile, fileInfo, logger)) {\n      logger.info(`Update has already been downloaded ${updateFile}).`)\n      return true\n    }\n\n    return false\n  }\n\n  setDownloadedFile(downloadedFile: string, packageFile: string | null, versionInfo: UpdateInfo, fileInfo: ResolvedUpdateFileInfo) {\n    this._file = downloadedFile\n    this._packageFile = packageFile\n    this.versionInfo = versionInfo\n    this.fileInfo = fileInfo\n  }\n\n  clear() {\n    this._file = null\n    this._packageFile = null\n    this.versionInfo = null\n    this.fileInfo = null\n  }\n\n  private static async isUpdateValid(updateFile: string, fileInfo: ResolvedUpdateFileInfo, logger: Logger): Promise<boolean> {\n    if (!(await pathExists(updateFile))) {\n      logger.info(\"No cached update available\")\n      return false\n    }\n\n    const sha512 = await hashFile(updateFile)\n    if (fileInfo.info.sha512 !== sha512) {\n      logger.warn(`Sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${sha512}, expected: ${fileInfo.info.sha512}`)\n      return false\n    }\n    return true\n  }\n}\n\nfunction hashFile(file: string, algorithm: string = \"sha512\", encoding: \"base64\" | \"hex\" = \"base64\", options?: any) {\n  return new Promise<string>((resolve, reject) => {\n    const hash = createHash(algorithm)\n    hash\n      .on(\"error\", reject)\n      .setEncoding(encoding)\n\n    createReadStream(file, {...options, highWaterMark: 1024 * 1024 /* better to use more memory but hash faster */})\n      .on(\"error\", reject)\n      .on(\"end\", () => {\n        hash.end()\n        resolve(hash.read() as string)\n      })\n      .pipe(hash, {end: false})\n  })\n}"]}
