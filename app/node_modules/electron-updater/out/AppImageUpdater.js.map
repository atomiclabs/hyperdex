{"version":3,"file":"AppImageUpdater.js","sourceRoot":"","sources":["../src/AppImageUpdater.ts"],"names":[],"mappings":"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","sourcesContent":["import { AllPublishOptions, CancellationToken, DownloadOptions, newError, UpdateInfo } from \"builder-util-runtime\"\nimport { execFileSync, spawn } from \"child_process\"\nimport isDev from \"electron-is-dev\"\nimport { chmod, unlinkSync } from \"fs-extra-p\"\nimport * as path from \"path\"\nimport \"source-map-support/register\"\nimport { BaseUpdater } from \"./BaseUpdater\"\nimport { FileWithEmbeddedBlockMapDifferentialDownloader } from \"./differentialDownloader/FileWithEmbeddedBlockMapDifferentialDownloader\"\nimport { UpdateCheckResult } from \"./main\"\nimport { findFile } from \"./Provider\"\n\nexport class AppImageUpdater extends BaseUpdater {\n  constructor(options?: AllPublishOptions | null, app?: any) {\n    super(options, app)\n  }\n\n  checkForUpdatesAndNotify(): Promise<UpdateCheckResult | null> {\n    if (isDev) {\n      return Promise.resolve(null)\n    }\n\n    if (process.env.APPIMAGE == null) {\n      if (process.env.SNAP == null) {\n        this._logger.warn(\"APPIMAGE env is not defined, current application is not an AppImage\")\n      }\n      else {\n        this._logger.info(\"SNAP env is defined, updater is disabled\")\n      }\n      return Promise.resolve(null)\n    }\n\n    return super.checkForUpdatesAndNotify()\n  }\n\n  /*** @private */\n  protected async doDownloadUpdate(updateInfo: UpdateInfo, cancellationToken: CancellationToken): Promise<Array<string>> {\n    const provider = await this.provider\n    const fileInfo = findFile(provider.resolveFiles(updateInfo), \"AppImage\")!!\n\n    const requestHeaders = await this.computeRequestHeaders()\n    const downloadOptions: DownloadOptions = {\n      skipDirCreation: true,\n      headers: requestHeaders,\n      cancellationToken,\n      sha512: fileInfo.info.sha512,\n    }\n\n    return await this.executeDownload({\n      fileExtension: \"AppImage\",\n      downloadOptions,\n      fileInfo,\n      updateInfo,\n      task: async updateFile => {\n        const oldFile = process.env.APPIMAGE!!\n        if (oldFile == null) {\n          throw newError(\"APPIMAGE env is not defined\", \"ERR_UPDATER_OLD_FILE_NOT_FOUND\")\n        }\n\n        let isDownloadFull = false\n        try {\n          await new FileWithEmbeddedBlockMapDifferentialDownloader(fileInfo.info, this.httpExecutor, {\n            newUrl: fileInfo.url.href,\n            oldFile,\n            logger: this._logger,\n            newFile: updateFile,\n            useMultipleRangeRequest: provider.useMultipleRangeRequest,\n            requestHeaders,\n          })\n            .download()\n        }\n        catch (e) {\n          this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`)\n          // during test (developer machine mac) we must throw error\n          isDownloadFull = process.platform === \"linux\"\n        }\n\n        if (isDownloadFull) {\n          await this.httpExecutor.download(fileInfo.url.href, updateFile, downloadOptions)\n        }\n\n        await chmod(updateFile, 0o755)\n      },\n    })\n  }\n\n  protected doInstall(installerPath: string, isSilent: boolean, isRunAfter: boolean): boolean {\n    const appImageFile = process.env.APPIMAGE!!\n    if (appImageFile == null) {\n      throw newError(\"APPIMAGE env is not defined\", \"ERR_UPDATER_OLD_FILE_NOT_FOUND\")\n    }\n\n    // https://stackoverflow.com/a/1712051/1910191\n    unlinkSync(appImageFile)\n\n    let destination: string\n    if (path.basename(installerPath) === path.basename(appImageFile)) {\n      // no version in the file name, overwrite existing\n      destination = appImageFile\n    }\n    else {\n      destination = path.join(path.dirname(appImageFile), path.basename(installerPath))\n    }\n\n    execFileSync(\"mv\", [\"-f\", installerPath, destination])\n\n    const env: any = {\n      ...process.env,\n      APPIMAGE_SILENT_INSTALL: \"true\",\n    }\n\n    if (isRunAfter) {\n      spawn(destination, [], {\n        detached: true,\n        stdio: \"ignore\",\n        env,\n      })\n        .unref()\n    }\n    else {\n      env.APPIMAGE_EXIT_AFTER_INSTALL = \"true\"\n      execFileSync(destination, [], {env})\n    }\n    return true\n  }\n}"]}
