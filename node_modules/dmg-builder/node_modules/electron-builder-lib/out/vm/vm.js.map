{"version":3,"file":"vm.js","sourceRoot":"","sources":["../../src/vm/vm.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,AAAO,AAAe,AAAI,AAAqB,AAAyB,AAAE,AAAK,AAAE,AAAM,AAAc;;;;;;;;;;AAErG,AAAO,AAAK,AAAI,AAAM,AAAM;;AAC5B,AAAO,AAAE,AAAkB,AAAE,AAAW,AAAE,AAAM,AAAe,AAE/D,AAAM;;;;;;;;;;;;;AACJ,MAAI,AAAO;AACT,WAAO,AAAI,KAAC,AAAG,AACjB;AAAC;;AAED,AAAI,OAAC,AAAY,MAAE,AAAmB,MAAE,AAAyB,SAAE,AAAe,kBAAG,AAAI;AACvF,WAAO,AAAI,yBAAC,AAAI,MAAE,AAAI,MAAE,AAAO,SAAE,AAAe,AAAC,AACnD;AAAC;;AAED,AAAK,QAAC,AAAY,MAAE,AAAmB,MAAE,AAAsB,SAAE,AAAgC;AAC/F,WAAO,AAAK,0BAAC,AAAI,MAAE,AAAI,MAAE,AAAO,SAAE,AAAY,AAAC,AACjD;AAAC;;AAED,AAAQ,WAAC,AAAY;AACnB,WAAO,AAAI,AACb;AAAC,AACF,AAED,AAAM;;;;;;;2CAAC,AAAK,WAAuB,AAAwB;AACzD,UAAM,AAAM,SAAG,CAAC,MAAM,AAAW,gCAAC,AAAW,AAAC,AAAC,cAAC,AAAM,OAAC,AAAE,AAAC,AAAE,MAAC,AAAE,GAAC,AAAE,OAAK,AAAQ,AAAC;;AAChF,QAAI,AAAM,OAAC,AAAM,WAAK,AAAC,GAAE;AACvB,YAAM,KAAI,AAAyB,0CAAC,AAAiF,AAAC;AACvH,MAED,AAAiC;;;AACjC,WAAO,KAAI,AAAkB,mCAAC,AAAM,OAAC,AAAI,KAAC,AAAE,AAAC,AAAE,MAAC,AAAE,GAAC,AAAK,UAAK,AAAS,AAAC,cAAI,AAAM,OAAC,AAAI,KAAC,AAAE,AAAC,AAAE,MAAC,AAAE,GAAC,AAAK,UAAK,AAAW,AAAC,gBAAI,AAAM,OAAC,AAAC,AAAC,AAAC,AACtI;AAAC","sourcesContent":["import { DebugLogger, exec, ExtraSpawnOptions, InvalidConfigurationError, spawn } from \"builder-util\"\nimport { ExecFileOptions, SpawnOptions } from \"child_process\"\nimport * as path from \"path\"\nimport { ParallelsVmManager, parseVmList } from \"./ParallelsVm\"\n\nexport class VmManager {\n  get pathSep(): string {\n    return path.sep\n  }\n\n  exec(file: string, args: Array<string>, options?: ExecFileOptions, isLogOutIfDebug = true): Promise<string> {\n    return exec(file, args, options, isLogOutIfDebug)\n  }\n\n  spawn(file: string, args: Array<string>, options?: SpawnOptions, extraOptions?: ExtraSpawnOptions): Promise<any> {\n    return spawn(file, args, options, extraOptions)\n  }\n\n  toVmFile(file: string): string {\n    return file\n  }\n}\n\nexport async function getWindowsVm(debugLogger: DebugLogger): Promise<VmManager> {\n  const vmList = (await parseVmList(debugLogger)).filter(it => it.os === \"win-10\")\n  if (vmList.length === 0) {\n    throw new InvalidConfigurationError(\"Cannot find suitable Parallels Desktop virtual machine (Windows 10 is required)\")\n  }\n\n  // prefer running or suspended vm\n  return new ParallelsVmManager(vmList.find(it => it.state === \"running\") || vmList.find(it => it.state === \"suspended\") || vmList[0])\n}"]}
