"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readEmbeddedBlockMapData = readEmbeddedBlockMapData;
exports.BLOCK_MAP_FILE_NAME = void 0;

function _bluebirdLst() {
  const data = _interopRequireDefault(require("bluebird-lst"));

  _bluebirdLst = function () {
    return data;
  };

  return data;
}

function _fsExtraP() {
  const data = require("fs-extra-p");

  _fsExtraP = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const BLOCK_MAP_FILE_NAME = "_blockMap.blockmap";
exports.BLOCK_MAP_FILE_NAME = BLOCK_MAP_FILE_NAME;

async function readEmbeddedBlockMapData(file) {
  const fd = await (0, _fsExtraP().open)(file, "r");

  try {
    const fileSize = (await (0, _fsExtraP().fstat)(fd)).size;
    const sizeBuffer = Buffer.allocUnsafe(4);
    await (0, _fsExtraP().read)(fd, sizeBuffer, 0, sizeBuffer.length, fileSize - sizeBuffer.length);
    const dataBuffer = Buffer.allocUnsafe(sizeBuffer.readUInt32BE(0));
    await (0, _fsExtraP().read)(fd, dataBuffer, 0, dataBuffer.length, fileSize - sizeBuffer.length - dataBuffer.length);
    await (0, _fsExtraP().close)(fd);

    const inflateRaw = _bluebirdLst().default.promisify(require("zlib").inflateRaw);

    return (await inflateRaw(dataBuffer)).toString();
  } catch (e) {
    await (0, _fsExtraP().close)(fd);
    throw e;
  }
} 
//# sourceMappingURL=blockMapApi.js.map