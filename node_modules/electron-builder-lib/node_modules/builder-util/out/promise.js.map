{"version":3,"file":"promise.js","sourceRoot":"","sources":["../src/promise.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,AAAO,AAAK,AAAM,AAAO,AAEzB,AAAM;;;;;;;;;;;;2BAA4B,AAAY;AAC5C,AAAO,UAAC,AAAK,MAAC,AAAK,iBAAC,AAAG,IAAC,CAAC,AAAK,MAAC,AAAK,SAAI,AAAK,AAAC,OAAC,AAAQ,AAAE,AAAC,AAAC;AAC3D,AAAO,UAAC,AAAI,KAAC,AAAC,AAAC,AACjB;AAAC,EAED,AAA6F,AAC7F,AAAM;;;;2CAAC,AAAK,WAA4B,AAAmB,SAAE,AAA8C;AACzG,QAAI,AAAM,SAAa,AAAI;;AAC3B,QAAI;AACF,AAAM,eAAG,MAAM,AAAO;AACvB,MACD,OAAO,AAAa,eAAE;AACpB,UAAI;AACF,cAAM,AAAI,KAAC,AAAI,AAAC;AACjB,QACD,OAAO,AAAS,WAAE;AAChB,cAAM,IAAI,AAAW,YAAC,CAAC,AAAa,eAAE,AAAS,AAAC,AAAC;AAClD;;AAED,YAAM,AAAa;AACpB;;AAED,QAAI;AACF,YAAM,AAAI,KAAC,AAAK,AAAC;AAClB,MACD,OAAO,AAAS,WAAE;AAChB,YAAM,AAAS;AAChB;;AACD,WAAO,AAAM,AACf;AAAC,AAED,AAAM;;;;;;;;;MAAmB,oBAAQ,AAAK;AACpC,cAAY,AAAoB,QAAE,UAAkB,AAAkB;AACpE,QAAI,AAAC,IAAG,AAAO;AACf,QAAI,AAAC,IAAG,AAAC;;AACT,SAAK,MAAM,AAAK,SAAI,AAAM,QAAE;AAC1B,YAAM,AAAM,AAAG,mBAAU,AAAC,AAAE,GAAG;AAC/B,AAAC,WAAI,AAAM,SAAG,AAAM,SAAG,AAAG,IAAC,AAAM,OAAC,AAAE,AAAC,MAAG,AAAI,OAAG,AAAM,MAAC,AAAK;AAC5D;;AACD,AAAK,UAAC,AAAC,AAAC,AACV;AAAC,AACF,AAED,AAAM;;;;;;8BAAkC,AAAmB;AACzD,SAAO,AAAgB,iBAAC,AAAO,SAAE,AAAI,AAAC,AACxC;AAAC,AAED,AAAM;;0BAA8B,AAAmB,SAAE,AAAgB;AACvE,iBACG,AAAK,MAAC,AAAC,AAAC,AAAE;AACT,QAAI,AAAC,EAAC,AAAI,SAAK,AAAQ,YAAI,AAAC,EAAC,AAAI,SAAK,AAAS,WAAE;AAC/C,aAAO,AAAa;AACrB;;AACD,UAAM,AAAC,AACT;AAAC,AAAC,AACN,GAPS,AAAO;AAOf","sourcesContent":["import chalk from \"chalk\"\n\nexport function printErrorAndExit(error: Error) {\n  console.error(chalk.red((error.stack || error).toString()))\n  process.exit(1)\n}\n\n// you don't need to handle error in your task - it is passed only indicate status of promise\nexport async function executeFinally<T>(promise: Promise<T>, task: (errorOccurred: boolean) => Promise<any>): Promise<T> {\n  let result: T | null = null\n  try {\n    result = await promise\n  }\n  catch (originalError) {\n    try {\n      await task(true)\n    }\n    catch (taskError) {\n      throw new NestedError([originalError, taskError])\n    }\n\n    throw originalError\n  }\n\n  try {\n    await task(false)\n  }\n  catch (taskError) {\n    throw taskError\n  }\n  return result\n}\n\nexport class NestedError extends Error {\n  constructor(errors: Array<Error>, message: string = \"Compound error: \") {\n    let m = message\n    let i = 1\n    for (const error of errors) {\n      const prefix = `Error #${i++} `\n      m += \"\\n\\n\" + prefix + \"-\".repeat(80) + \"\\n\" + error!.stack\n    }\n    super(m)\n  }\n}\n\nexport function orNullIfFileNotExist<T>(promise: Promise<T>): Promise<T | null> {\n  return orIfFileNotExist(promise, null)\n}\n\nexport function orIfFileNotExist<T>(promise: Promise<T>, fallbackValue: T): Promise<T> {\n  return promise\n    .catch(e => {\n      if (e.code === \"ENOENT\" || e.code === \"ENOTDIR\") {\n        return fallbackValue\n      }\n      throw e\n    })\n}"]}
