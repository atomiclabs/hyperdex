{"version":3,"file":"unpackDetector.js","sourceRoot":"","sources":["../../src/asar/unpackDetector.ts"],"names":[],"mappings":"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","sourcesContent":["import BluebirdPromise from \"bluebird-lst\"\nimport { log } from \"builder-util\"\nimport { CONCURRENCY } from \"builder-util/out/fs\"\nimport { ensureDir } from \"fs-extra-p\"\nimport * as path from \"path\"\nimport { NODE_MODULES_PATTERN } from \"../fileTransformer\"\nimport { getDestinationPath } from \"../util/appFileCopier\"\nimport { ResolvedFileSet } from \"../util/AppFileCopierHelper\"\n\nconst isBinaryFile: any = BluebirdPromise.promisify(require(\"isbinaryfile\"))\n\nfunction addValue(map: Map<string, Array<string>>, key: string, value: string) {\n  let list = map.get(key)\n  if (list == null) {\n    list = [value]\n    map.set(key, list)\n  }\n  else {\n    list.push(value)\n  }\n}\n\n/** @internal */\nexport async function detectUnpackedDirs(fileSet: ResolvedFileSet, autoUnpackDirs: Set<string>, unpackedDest: string, rootForAppFilesWithoutAsar: string) {\n  const dirToCreate = new Map<string, Array<string>>()\n  const metadata = fileSet.metadata\n\n  function addParents(child: string, root: string) {\n    child = path.dirname(child)\n    if (autoUnpackDirs.has(child)) {\n      return\n    }\n\n    do {\n      autoUnpackDirs.add(child)\n      const p = path.dirname(child)\n      // create parent dir to be able to copy file later without directory existence check\n      addValue(dirToCreate, p, path.basename(child))\n\n      if (child === root || p === root || autoUnpackDirs.has(p)) {\n        break\n      }\n      child = p\n    }\n    while (true)\n\n    autoUnpackDirs.add(root)\n  }\n\n  for (let i = 0, n = fileSet.files.length; i < n; i++) {\n    const file = fileSet.files[i]\n    const index = file.lastIndexOf(NODE_MODULES_PATTERN)\n    if (index < 0) {\n      continue\n    }\n\n    let nextSlashIndex = file.indexOf(path.sep, index + NODE_MODULES_PATTERN.length + 1)\n    if (nextSlashIndex < 0) {\n      continue\n    }\n\n    if (file[index + NODE_MODULES_PATTERN.length] === \"@\") {\n      nextSlashIndex = file.indexOf(path.sep, nextSlashIndex + 1)\n    }\n\n    if (!metadata.get(file)!.isFile()) {\n      continue\n    }\n\n    const packageDir = file.substring(0, nextSlashIndex)\n    const packageDirPathInArchive = path.relative(rootForAppFilesWithoutAsar, getDestinationPath(packageDir, fileSet))\n    const pathInArchive = path.relative(rootForAppFilesWithoutAsar, getDestinationPath(file, fileSet))\n    if (autoUnpackDirs.has(packageDirPathInArchive)) {\n      // if package dir is unpacked, any file also unpacked\n      addParents(pathInArchive, packageDirPathInArchive)\n      continue\n    }\n\n    // https://github.com/electron-userland/electron-builder/issues/2679\n    let shouldUnpack = false\n    if (file.endsWith(\".dll\") || file.endsWith(\".exe\") || file.endsWith(\".dylib\")) {\n      shouldUnpack = true\n    }\n    else if (!file.includes(\".\", nextSlashIndex) && path.extname(file) === \"\") {\n      shouldUnpack = await isBinaryFile(file)\n    }\n\n    if (!shouldUnpack) {\n      continue\n    }\n\n    if (log.isDebugEnabled) {\n      log.debug({file: pathInArchive, reason: \"contains executable code\"}, \"not packed into asar archive\")\n    }\n\n    addParents(pathInArchive, packageDirPathInArchive)\n  }\n\n  if (dirToCreate.size > 0) {\n    await ensureDir(unpackedDest + path.sep + \"node_modules\")\n    // child directories should be not created asynchronously - parent directories should be created first\n    await BluebirdPromise.map(dirToCreate.keys(), async parentDir => {\n      const base = unpackedDest + path.sep + parentDir\n      await ensureDir(base)\n      await BluebirdPromise.each(dirToCreate.get(parentDir)!, (it): any => {\n        if (dirToCreate.has(parentDir + path.sep + it)) {\n          // already created\n          return null\n        }\n        else {\n          return ensureDir(base + path.sep + it)\n        }\n      })\n    }, CONCURRENCY)\n  }\n}"]}
